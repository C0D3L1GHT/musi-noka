<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Balls</title>
    <style>
        body {
            background-color: #1a1a1a;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Inter', sans-serif;
            color: #fff;
        }
        canvas {
            background-color: #2a2a2a;
            border: 2px solid #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
            border-radius: 10px;
        }
        #message-box {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: block;
            z-index: 100;
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            font-size: 1.2rem;
            max-width: 80%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="bouncingCanvas"></canvas>
    <div id="message-box">Click to Start</div>

    <script>
        // Get the canvas element and its 2D rendering context
        const canvas = document.getElementById('bouncingCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('message-box');
        
        let gameActive = false;
        let animationFrameId = null;
        let balls = [];
        let walls = [];
        let goal = {};

        // Load the collision sound effect
        const collisionSound = new Audio('https://cdn.jsdelivr.net/gh/johannes-t-keller/sound-effects@main/audio/glass_002.ogg');
        collisionSound.volume = 0.5;

        // Function to play the sound effect
        function playCollisionSound() {
            if (collisionSound.paused) {
                collisionSound.play().catch(e => console.error("Audio play failed:", e));
            } else {
                const soundClone = collisionSound.cloneNode();
                soundClone.play().catch(e => console.error("Audio play failed:", e));
            }
        }

        // Set the canvas size to the window dimensions for a full-screen effect
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.8;
            canvas.height = window.innerHeight * 0.8;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- Ball Class ---
        class Ball {
            constructor(x, y, radius, color, speed) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                const angle = Math.random() * 2 * Math.PI;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                // Add properties to track how long the ball has been moving in one direction
                this.stuckXFrames = 0;
                this.stuckYFrames = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
                this.drawEyes();
            }

            drawEyes() {
                const eyeRadius = this.radius * 0.2;
                const pupilRadius = this.radius * 0.1;

                const eye1X = this.x - this.radius * 0.4;
                const eye2X = this.x + this.radius * 0.4;
                const eyeY = this.y;

                const eyeDirectionX = this.vx / Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const eyeDirectionY = this.vy / Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const pupilOffset = eyeRadius * 0.5;
                const pupil1X = eye1X + eyeDirectionX * pupilOffset;
                const pupil2X = eye2X + eyeDirectionX * pupilOffset;
                const pupilY = eyeY + eyeDirectionY * pupilOffset;
                
                ctx.beginPath();
                ctx.arc(eye1X, eyeY, eyeRadius, 0, Math.PI * 2);
                ctx.arc(eye2X, eyeY, eyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.closePath();

                ctx.beginPath();
                ctx.arc(pupil1X, pupilY, pupilRadius, 0, Math.PI * 2);
                ctx.arc(pupil2X, pupilY, pupilRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.closePath();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            checkWallCollision() {
                if (this.x - this.radius <= 0 || this.x + this.radius >= canvas.width) {
                    this.vx *= -1;
                    playCollisionSound();
                }
                if (this.y - this.radius <= 0 || this.y + this.radius >= canvas.height) {
                    this.vy *= -1;
                    playCollisionSound();
                }
            }

            checkBallCollision(otherBall) {
                const dx = otherBall.x - this.x;
                const dy = otherBall.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const combinedRadius = this.radius + otherBall.radius;

                if (distance < combinedRadius) {
                    playCollisionSound();
                    const overlap = combinedRadius - distance;
                    const normalX = dx / distance;
                    const normalY = dy / distance;

                    this.x -= normalX * (overlap / 2);
                    this.y -= normalY * (overlap / 2);
                    otherBall.x += normalX * (overlap / 2);
                    otherBall.y += normalY * (overlap / 2);

                    this.vx *= -1;
                    this.vy *= -1;
                    otherBall.vx *= -1;
                    otherBall.vy *= -1;
                }
            }

            checkWallCollisionWithObject(wall) {
                let testX = this.x;
                let testY = this.y;

                if (this.x < wall.x) {
                    testX = wall.x;
                } else if (this.x > wall.x + wall.width) {
                    testX = wall.x + wall.width;
                }

                if (this.y < wall.y) {
                    testY = wall.y;
                } else if (this.y > wall.y + wall.height) {
                    testY = wall.y + wall.height;
                }

                let distX = this.x - testX;
                let distY = this.y - testY;
                let distance = Math.sqrt((distX * distX) + (distY * distY));

                if (distance <= this.radius) {
                    playCollisionSound();
                    const overlap = this.radius - distance;
                    const pushX = distX / distance;
                    const pushY = distY / distance;

                    this.x += pushX * overlap;
                    this.y += pushY * overlap;

                    if (Math.abs(distX) > Math.abs(distY)) {
                        this.vx *= -1;
                    } else {
                        this.vy *= -1;
                    }
                }
            }
        }

        // --- Maze Generation and Game Initialization ---
        const numBalls = 6;
        const colors = ['#FF0000', '#0000FF', '#FFFFFF', '#000000', '#FFFF00', '#008000'];
        const initialSpeed = 5;
        const STUCK_FRAMES_THRESHOLD = 60 * 10; // 10 seconds at 60 FPS

        const WALL_THICKNESS = 10;
        const CELL_SIZE = 50;

        function generateMaze() {
            walls = [];
            const mazeCols = Math.floor(canvas.width / CELL_SIZE) - 1;
            const mazeRows = Math.floor(canvas.height / CELL_SIZE) - 1;

            const grid = Array.from({ length: mazeRows }, () => Array(mazeCols).fill(false));
            const wallList = [];
            const allWalls = [];

            // Initialize all walls
            for (let r = 0; r < mazeRows; r++) {
                for (let c = 0; c < mazeCols; c++) {
                    if (r < mazeRows - 1) {
                        allWalls.push({
                            x1: (c + 1) * CELL_SIZE, y1: (r + 1) * CELL_SIZE,
                            x2: (c + 1) * CELL_SIZE, y2: (r + 2) * CELL_SIZE,
                            type: 'vertical'
                        });
                    }
                    if (c < mazeCols - 1) {
                        allWalls.push({
                            x1: (c + 1) * CELL_SIZE, y1: (r + 1) * CELL_SIZE,
                            x2: (c + 2) * CELL_SIZE, y2: (r + 1) * CELL_SIZE,
                            type: 'horizontal'
                        });
                    }
                }
            }

            // Prim's algorithm
            let startRow = 0;
            let startCol = 0;
            grid[startRow][startCol] = true;

            const addWalls = (r, c) => {
                if (r > 0 && !grid[r - 1][c]) wallList.push({ r: r - 1, c: c, fromR: r, fromC: c, type: 'top' });
                if (r < mazeRows - 1 && !grid[r + 1][c]) wallList.push({ r: r + 1, c: c, fromR: r, fromC: c, type: 'bottom' });
                if (c > 0 && !grid[r][c - 1]) wallList.push({ r: r, c: c - 1, fromR: r, fromC: c, type: 'left' });
                if (c < mazeCols - 1 && !grid[r][c + 1]) wallList.push({ r: r, c: c + 1, fromR: r, fromC: c, type: 'right' });
            };
            addWalls(startRow, startCol);

            while (wallList.length > 0) {
                const randomIndex = Math.floor(Math.random() * wallList.length);
                const wall = wallList[randomIndex];
                wallList.splice(randomIndex, 1);

                if (!grid[wall.r][wall.c]) {
                    grid[wall.r][wall.c] = true;
                    // Remove the wall from allWalls
                    let wallToRemove = null;
                    if (wall.type === 'top') {
                        wallToRemove = allWalls.find(w => w.x1 === (wall.c + 1) * CELL_SIZE && w.y1 === (wall.r + 2) * CELL_SIZE && w.type === 'horizontal');
                    } else if (wall.type === 'bottom') {
                        wallToRemove = allWalls.find(w => w.x1 === (wall.c + 1) * CELL_SIZE && w.y1 === (wall.r + 1) * CELL_SIZE && w.type === 'horizontal');
                    } else if (wall.type === 'left') {
                        wallToRemove = allWalls.find(w => w.x1 === (wall.c + 1) * CELL_SIZE && w.y1 === (wall.r + 1) * CELL_SIZE && w.type === 'vertical');
                    } else if (wall.type === 'right') {
                        wallToRemove = allWalls.find(w => w.x1 === (wall.c + 1) * CELL_SIZE && w.y1 === (wall.r + 1) * CELL_SIZE && w.type === 'vertical');
                    }
                    if (wallToRemove) {
                        const index = allWalls.indexOf(wallToRemove);
                        if (index > -1) {
                            allWalls.splice(index, 1);
                        }
                    }
                    addWalls(wall.r, wall.c);
                }
            }

            walls = allWalls.map(w => {
                let x = Math.min(w.x1, w.x2);
                let y = Math.min(w.y1, w.y2);
                let width = w.type === 'horizontal' ? Math.abs(w.x2 - w.x1) : WALL_THICKNESS;
                let height = w.type === 'vertical' ? Math.abs(w.y2 - w.y1) : WALL_THICKNESS;
                return { x, y, width, height };
            });

            // Remove half of the remaining walls
            const numToRemove = Math.floor(walls.length / 2);
            for (let i = 0; i < numToRemove; i++) {
                const randomIndex = Math.floor(Math.random() * walls.length);
                walls.splice(randomIndex, 1);
            }
            
            // Add outer border walls
            walls.push(
                { x: 0, y: 0, width: canvas.width, height: WALL_THICKNESS },
                { x: 0, y: canvas.height - WALL_THICKNESS, width: canvas.width, height: WALL_THICKNESS },
                { x: 0, y: 0, width: WALL_THICKNESS, height: canvas.height },
                { x: canvas.width - WALL_THICKNESS, y: 0, width: WALL_THICKNESS, height: canvas.height }
            );

            // Ensure the top-left corner is clear
            walls = walls.filter(wall => {
                const startArea = { x: 0, y: 0, width: CELL_SIZE * 2, height: CELL_SIZE * 2 };
                return !(wall.x < startArea.x + startArea.width &&
                         wall.x + wall.width > startArea.x &&
                         wall.y < startArea.y + startArea.height &&
                         wall.y + wall.height > startArea.y);
            });

            setGoalPosition();
        }

        function setGoalPosition() {
            const goalSize = 50;
            const positions = [
                'center', 'topRight', 'bottomLeft', 'bottomRight'
            ];
            const randomPos = positions[Math.floor(Math.random() * positions.length)];

            if (randomPos === 'topRight') {
                goal.x = canvas.width - goalSize - 10;
                goal.y = 10;
            } else if (randomPos === 'bottomLeft') {
                goal.x = 10;
                goal.y = canvas.height - goalSize - 10;
            } else if (randomPos === 'bottomRight') {
                goal.x = canvas.width - goalSize - 10;
                goal.y = canvas.height - goalSize - 10;
            } else { // center
                goal.x = canvas.width / 2 - goalSize / 2;
                goal.y = canvas.height / 2 - goalSize / 2;
            }

            goal.width = goalSize;
            goal.height = goalSize;

            const goalCenter = { x: goal.x + goal.width / 2, y: goal.y + goal.height / 2 };

            let adjacentWalls = [];
            walls = walls.filter(wall => {
                const wallCenter = { x: wall.x + wall.width / 2, y: wall.y + wall.height / 2 };
                const dx = Math.abs(goalCenter.x - wallCenter.x);
                const dy = Math.abs(goalCenter.y - wallCenter.y);
                const isAdjacent = dx <= (goal.width / 2 + wall.width / 2) + 20 && dy <= (goal.height / 2 + wall.height / 2) + 20;

                if (isAdjacent) {
                    adjacentWalls.push(wall);
                    return false;
                }
                return true;
            });

            while (adjacentWalls.length > 2) {
                const randomIndex = Math.floor(Math.random() * adjacentWalls.length);
                adjacentWalls.splice(randomIndex, 1);
            }

            walls.push(...adjacentWalls);
        }

        function resetBalls() {
            balls = [];
            const radius = 15;
            const startX = 50;
            const startY = 50;
            for (let i = 0; i < numBalls; i++) {
                balls.push(new Ball(startX, startY, radius, colors[i % colors.length], initialSpeed));
            }
        }
        
        // --- Game Loop ---
        function gameLoop() {
            if (!gameActive) {
                return;
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#8c8c8c';
            walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });

            ctx.fillStyle = '#00aa00';
            ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

            for (let i = 0; i < balls.length; i++) {
                const ball = balls[i];
                ball.update();
                ball.checkWallCollision();
                
                walls.forEach(wall => {
                    ball.checkWallCollisionWithObject(wall);
                });

                // Stuck detection and teleportation logic
                if (Math.abs(ball.vy) < 0.1) { // Check if moving mostly horizontally
                    ball.stuckXFrames++;
                    ball.stuckYFrames = 0;
                } else if (Math.abs(ball.vx) < 0.1) { // Check if moving mostly vertically
                    ball.stuckYFrames++;
                    ball.stuckXFrames = 0;
                } else {
                    ball.stuckXFrames = 0;
                    ball.stuckYFrames = 0;
                }
                
                if (ball.stuckXFrames > STUCK_FRAMES_THRESHOLD) {
                    ball.y += (Math.random() > 0.5 ? 10 : -10); // Teleport up or down
                    ball.stuckXFrames = 0;
                    ball.stuckYFrames = 0;
                }

                if (ball.stuckYFrames > STUCK_FRAMES_THRESHOLD) {
                    ball.x += (Math.random() > 0.5 ? 10 : -10); // Teleport left or right
                    ball.stuckXFrames = 0;
                    ball.stuckYFrames = 0;
                }

                if (ball.x + ball.radius > goal.x &&
                    ball.x - ball.radius < goal.x + goal.width &&
                    ball.y + ball.radius > goal.y &&
                    ball.y - ball.radius < goal.y + goal.height) {
                    
                    gameActive = false;
                    messageBox.innerText = 'Game Over! A ball has reached the goal!';
                    messageBox.style.display = 'block';
                    return;
                }
            }

            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    balls[i].checkBallCollision(balls[j]);
                }
            }

            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Event Listener to Start Game on Click ---
        canvas.addEventListener('click', startGame, { once: true });
        messageBox.addEventListener('click', startGame, { once: true });
        
        function startGame() {
            gameActive = true;
            messageBox.style.display = 'none';
            generateMaze();
            resetBalls();
            gameLoop();
        }

        // Initial setup
        window.onload = function() {
            // No need to call setGoalPosition here, it's called inside generateMaze
        };

    </script>
</body>
</html>
